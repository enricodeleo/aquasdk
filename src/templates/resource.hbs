import { QueryBuilder } from '../utils/queryUtils.js';

/**
 * {{pascalCase resource.name}} Resource
 * Generated: {{timestamp}}
 */
export default class {{pascalCase resource.name}}Resource {
  /**
   * Create a new {{pascalCase resource.name}} resource
   * @param {ApiClient} client - API client instance
   */
  constructor(client) {
    this.client = client;
  }

  /**
   * Starts a new query for finding records.
   * @param {Object} [criteria] - The criteria to filter records.
   * @returns {QueryBuilder} A QueryBuilder instance.
   */
  find(criteria) {
    return new QueryBuilder({
      client: this.client,
      method: 'get',
      path: '/{{resource.name}}',
      criteria,
    });
  }

  /**
   * Starts a new query for finding a single record.
   * @param {string|number|Object} [criteria] - The ID or criteria to find a single record.
   * @returns {QueryBuilder} A QueryBuilder instance that resolves to a single object.
   */
  findOne(criteria) {
    const path = (typeof criteria === 'string' || typeof criteria === 'number')
      ? '/{{resource.name}}/{id}'
      : '/{{resource.name}}';
      
    const filter = (typeof criteria === 'object' && criteria !== null) ? criteria : { id: criteria };

    const qb = new QueryBuilder({
      client: this.client,
      method: 'get',
      path: path,
      criteria: filter,
    });

    // Ensure findOne resolves to a single object, not an array
    const originalExecute = qb.execute;
    qb.execute = async function() {
      // If it's not a path-based ID lookup, enforce limit(1)
      if (!path.includes('/{id}')) {
        this.limit(1);
      }
      const response = await originalExecute.call(this);
      if (response.data && Array.isArray(response.data)) {
        return {
          ...response,
          data: response.data.length > 0 ? response.data[0] : null,
        };
      }
      return response;
    };
    
    return qb;
  }

  /**
   * Creates a new record.
   * @param {Object} data - The data for the new record.
   * @returns {Promise<any>} A promise that resolves with the created record.
   */
  create(data) {
    return this.client.request({
      method: 'post',
      url: '/{{resource.name}}',
      data,
    });
  }

  /**
   * Updates a record by its ID.
   * @param {string|number} id - The ID of the record to update.
   * @param {Object} data - The data to update the record with.
   * @returns {Promise<any>} A promise that resolves with the updated record.
   */
  update(id, data) {
    return this.client.request({
      method: 'patch',
      url: `/{{resource.name}}/${id}`,
      data,
    });
  }

  /**
   * Destroys a record by its ID.
   * @param {string|number} id - The ID of the record to destroy.
   * @returns {Promise<any>} A promise that resolves when the record is destroyed.
   */
  destroy(id) {
    return this.client.request({
      method: 'delete',
      url: `/{{resource.name}}/${id}`,
    });
  }

  {{#each resource.operations}}
  /**
   * {{summary}}
   * {{description}}
   {{#each pathParams}}
   * @param {string} {{this}} - Path parameter
   {{/each}}
   {{#if hasRequestBody}}
   * @param {Object} data - Request body
   {{/if}}
   {{#if queryParams.length}}
   * @param {Object} [query] - Query parameters
   {{/if}}
   * @returns {Promise<{{returnType}}>} - Response with data and headers
   */
  async {{camelCase id}}({{#if pathParams}}{{#each pathParams}}{{this}}, {{/each}}{{/if}}{{#if hasRequestBody}}data{{#if queryParams.length}}, {{/if}}{{/if}}{{#if queryParams.length}}query = {}{{/if}}) {
    let url = '{{path}}'
      {{#each pathParams}}
      .replace('{{{this}}}', encodeURIComponent({{this}}))
      {{/each}};

    return await this.client.request({
      method: '{{method}}',
      url,
      {{#if queryParams.length}}
      params: query,
      {{/if}}
      {{#if hasRequestBody}}
      data,
      {{/if}}
    });
  }
  {{/each}}
}

